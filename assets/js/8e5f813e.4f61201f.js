"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[526],{6016:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"framework","title":"Framework","description":"The Curator Framework is a high-level API that greatly simplifies using ZooKeeper. It adds many features that build on ZooKeeper and handles the complexity of managing connections to the ZooKeeper cluster and retrying operations. Some of the features are:","source":"@site/docs/framework.md","sourceDirName":".","slug":"/framework","permalink":"/docs/framework","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/framework.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1740888071000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Schema Support","permalink":"/docs/schema"},"next":{"title":"Utilities","permalink":"/docs/utilities"}}');var a=r(5105),i=r(6413);const s={},o="Framework",l={},d=[{value:"Allocating a Curator Framework Instance",id:"allocating-a-curator-framework-instance",level:2},{value:"CuratorFramework API",id:"curatorframework-api",level:2},{value:"Methods",id:"methods",level:3},{value:"Notifications",id:"notifications",level:3},{value:"CuratorEvent",id:"curatorevent",level:3},{value:"Namespaces",id:"namespaces",level:2},{value:"Temporary Connections",id:"temporary-connections",level:2},{value:"Creating a CuratorTempFramework",id:"creating-a-curatortempframework",level:3},{value:"Limited API",id:"limited-api",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"framework",children:"Framework"})}),"\n",(0,a.jsx)(t.p,{children:"The Curator Framework is a high-level API that greatly simplifies using ZooKeeper. It adds many features that build on ZooKeeper and handles the complexity of managing connections to the ZooKeeper cluster and retrying operations. Some of the features are:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Automatic connection management:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"There are potential error cases that require ZooKeeper clients to recreate a connection and/or retry operations. Curator automatically and transparently (mostly) handles these cases."}),"\n",(0,a.jsx)(t.li,{children:"Watches for NodeDataChanged events and calls updateServerList() as needed."}),"\n",(0,a.jsx)(t.li,{children:"Watches are automatically removed by Curator recipes"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Cleaner API:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"simplifies the raw ZooKeeper methods, events, etc."}),"\n",(0,a.jsx)(t.li,{children:"provides a modern, fluent interface"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Recipe implementations (see ",(0,a.jsx)(t.a,{href:"/docs/recipes",children:"Recipes"}),"):","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Leader election"}),"\n",(0,a.jsx)(t.li,{children:"Shared lock"}),"\n",(0,a.jsx)(t.li,{children:"Path cache and watcher"}),"\n",(0,a.jsx)(t.li,{children:"Distributed Queue"}),"\n",(0,a.jsx)(t.li,{children:"Distributed Priority Queue"}),"\n",(0,a.jsx)(t.li,{children:"..."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["A Java 8 asynchronous version of CuratorFramework is also available: ",(0,a.jsx)(t.a,{href:"/docs/async",children:"Curator Async"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"allocating-a-curator-framework-instance",children:"Allocating a Curator Framework Instance"}),"\n",(0,a.jsx)(t.p,{children:"CuratorFrameworks are allocated using the CuratorFrameworkFactory which provides both factory methods and a builder for creating instances. IMPORTANT: CuratorFramework instances are fully thread-safe. You should share one CuratorFramework per ZooKeeper cluster in your application."}),"\n",(0,a.jsx)(t.p,{children:"The factory methods (newClient()) provide a simplified way of creating an instance. The Builder gives control over all parameters. Once you have a CuratorFramework instance, you must call the start() method. At the end of your application, you should call close()."}),"\n",(0,a.jsx)(t.h2,{id:"curatorframework-api",children:"CuratorFramework API"}),"\n",(0,a.jsx)(t.p,{children:"The CuratorFramework uses a Fluent-style interface. Operations are constructed using builders returned by the CuratorFramework instance. When strung together, the methods form sentence-like statements. e.g.,"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:'client.create().forPath("/head", new byte[0]);\nclient.delete().inBackground().forPath("/head");\nclient.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child", new byte[0]);\nclient.getData().watched().inBackground().forPath("/test");\n'})}),"\n",(0,a.jsx)(t.h3,{id:"methods",children:"Methods"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Method"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"create()"}),(0,a.jsx)(t.td,{children:"Begins a create operation. Call additional methods (mode or background) and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"delete()"}),(0,a.jsx)(t.td,{children:"Begins a delete operation. Call additional methods (version or background) and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"checkExists()"}),(0,a.jsx)(t.td,{children:"Begins an operation to check that a ZNode exists. Call additional methods (watch or background) and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"getData()"}),(0,a.jsx)(t.td,{children:"Begins an operation to get a ZNode's data. Call additional methods (watch, background or get stat) and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"setData()"}),(0,a.jsx)(t.td,{children:"Begins an operation to set a ZNode's data. Call additional methods (version or background) and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"getChildren()"}),(0,a.jsx)(t.td,{children:"Begins an operation to get a ZNode's list of children ZNodes. Call additional methods (watch, background or get stat) and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"transactionOp()"}),(0,a.jsx)(t.td,{children:"Used to allocate operations to be used with transaction()."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"transaction()"}),(0,a.jsx)(t.td,{children:"Atomically submit a set of operations as a transaction."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"getACL()"}),(0,a.jsx)(t.td,{children:"Begins an operation to return a ZNode's ACL settings. Call additional methods and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"setACL()"}),(0,a.jsx)(t.td,{children:"Begins an operation to set a ZNode's ACL settings. Call additional methods and finalize the operation by calling forPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"getConfig()"}),(0,a.jsx)(t.td,{children:"Begins an operation to return the last committed configuration. Call additional methods and finalize the operation by calling forEnsemble()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"reconfig()"}),(0,a.jsx)(t.td,{children:"Begins an operation to change the configuration. Call additional methods and finalize the operation by calling forEnsemble()"})]})]})]}),"\n",(0,a.jsx)(t.h3,{id:"notifications",children:"Notifications"}),"\n",(0,a.jsx)(t.p,{children:"Notifications for background operations and watches are published via the ClientListener interface. You register listeners with the CuratorFramework instance using the addListener() method. The listener implements two methods:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Method"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsx)(t.tbody,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"eventReceived()"}),(0,a.jsx)(t.td,{children:"A background operation has completed or a watch has triggered. Examine the given event for details"})]})})]}),"\n",(0,a.jsx)(t.h3,{id:"curatorevent",children:"CuratorEvent"}),"\n",(0,a.jsx)(t.p,{children:"The CuratorEvent object is a super-set POJO that can hold every type of background notification and triggered watch. The useful fields of CuratorEvent depend on the type of event which is exposed via the getType() method."}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Event Type"}),(0,a.jsx)(t.th,{children:"Event Methods"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"CREATE"}),(0,a.jsx)(t.td,{children:"getResultCode() and getPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"DELETE"}),(0,a.jsx)(t.td,{children:"getResultCode() and getPath()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"EXISTS"}),(0,a.jsx)(t.td,{children:"getResultCode(), getPath() and getStat()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"GET_DATA"}),(0,a.jsx)(t.td,{children:"getResultCode(), getPath(), getStat() and getData()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"SET_DATA"}),(0,a.jsx)(t.td,{children:"getResultCode(), getPath() and getStat()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"CHILDREN"}),(0,a.jsx)(t.td,{children:"getResultCode(), getPath(), getStat(), getChildren()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"SYNC"}),(0,a.jsx)(t.td,{children:"getResultCode(), getStat()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"GET_ACL"}),(0,a.jsx)(t.td,{children:"getResultCode(), getACLList()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"SET_ACL"}),(0,a.jsx)(t.td,{children:"getResultCode()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"TRANSACTION"}),(0,a.jsx)(t.td,{children:"getResultCode(), getOpResults()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"WATCHED"}),(0,a.jsx)(t.td,{children:"getWatchedEvent()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"GET_CONFIG"}),(0,a.jsx)(t.td,{children:"getResultCode(), getData()"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"RECONFIG"}),(0,a.jsx)(t.td,{children:"getResultCode(), getData()"})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"namespaces",children:"Namespaces"}),"\n",(0,a.jsx)(t.p,{children:"Because a ZooKeeper cluster is a shared environment, it's vital that a namespace convention is observed so that various applications that use a given cluster don't use conflicting ZK paths."}),"\n",(0,a.jsx)(t.p,{children:'The CuratorFramework has a concept of a "namespace". You set the namespace when creating a CuratorFramework instance (via the Builder). The CuratorFramework will then prepend the namespace to all paths when one of its APIs is called. i.e.,'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:'CuratorFramework client = CuratorFrameworkFactory.builder().namespace("MyApp") ... build();\nclient.create().forPath("/test", data);\n// node was actually written to: "/MyApp/test"\n'})}),"\n",(0,a.jsx)(t.h2,{id:"temporary-connections",children:"Temporary Connections"}),"\n",(0,a.jsx)(t.p,{children:"Temporary CuratorFramework instances are meant for single requests to ZooKeeper ensembles over a failure prone network such as a WAN. The APIs available from CuratorTempFramework are limited. Further, the connection will be closed after a period of inactivity."}),"\n",(0,a.jsxs)(t.p,{children:["This is based on an idea mentioned in a post by Camille Fournier: ",(0,a.jsx)(t.a,{href:"http://whilefalse.blogspot.com/2012/12/building-global-highly-available.html",children:"http://whilefalse.blogspot.com/2012/12/building-global-highly-available.html"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"creating-a-curatortempframework",children:"Creating a CuratorTempFramework"}),"\n",(0,a.jsxs)(t.p,{children:["CuratorTempFramework instances are created via the CuratorFrameworkFactory just like normal CuratorFramework instances. However, instead of calling the ",(0,a.jsx)(t.code,{children:"build()"})," method, call ",(0,a.jsx)(t.code,{children:"buildTemp()"}),". ",(0,a.jsx)(t.code,{children:"buildTemp()"})," creates a CuratorTempFramework instance that closes itself after 3 minutes of inactivity. There is an alternate version of ",(0,a.jsx)(t.code,{children:"buildTemp()"})," that allows you to specify the inactivity period."]}),"\n",(0,a.jsx)(t.h3,{id:"limited-api",children:"Limited API"}),"\n",(0,a.jsx)(t.p,{children:"CuratorTempFramework instances provide the following methods:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"/**\n * Stop the client\n */\npublic void     close();\n\n/**\n * Start a transaction builder\n *\n * @return builder object\n * @throws Exception errors\n */\npublic CuratorTransaction inTransaction() throws Exception;\n\n/**\n * Start a get data builder\n *\n * @return builder object\n * @throws Exception errors\n */\npublic TempGetDataBuilder getData() throws Exception;\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},6413:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>o});var n=r(8101);const a={},i=n.createContext(a);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);