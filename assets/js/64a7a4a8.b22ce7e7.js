"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[1633],{4691:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>r,default:()=>o,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"schema","title":"Schema Support","description":"In larger ZooKeeper applications you will end with many paths to ZNodes that have specific meanings and uses. E.g. \\"/myapp/clients/clusters/instances\\" or \\"/myapp/writers/locks\\". These paths can become unwieldy and difficult to reason about. Ideally, you should have a simple way to commonly refer to these paths, a way to validate how they are used, and a way to document what they are used for.","source":"@site/docs/schema.md","sourceDirName":".","slug":"/schema","permalink":"/docs/schema","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/schema.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1741292192000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Migrations","permalink":"/docs/migrations"},"next":{"title":"Framework","permalink":"/docs/framework"}}');var s=t(5105),l=t(6413);const i={},r="Schema Support",d={},c=[{value:"Schema and SchemaSet",id:"schema-and-schemaset",level:2},{value:"SchemaValidator",id:"schemavalidator",level:3},{value:"Getting ZNode paths/schemas by name",id:"getting-znode-pathsschemas-by-name",level:2},{value:"Loading JSON Schema from a file/stream",id:"loading-json-schema-from-a-filestream",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3}];function h(e){const a={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"schema-support",children:"Schema Support"})}),"\n",(0,s.jsx)(a.p,{children:'In larger ZooKeeper applications you will end with many paths to ZNodes that have specific meanings and uses. E.g. "/myapp/clients/clusters/instances" or "/myapp/writers/locks". These paths can become unwieldy and difficult to reason about. Ideally, you should have a simple way to commonly refer to these paths, a way to validate how they are used, and a way to document what they are used for.'}),"\n",(0,s.jsx)(a.p,{children:"Curator provides a mechanism to:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Document your ZooKeeper paths"}),"\n",(0,s.jsx)(a.li,{children:"Validate operations on ZooKeeper paths"}),"\n",(0,s.jsx)(a.li,{children:"Map a simple string to a ZooKeeper path"}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["When a Curator operation violates a schema, ",(0,s.jsx)(a.code,{children:"SchemaViolation"})," is thrown."]}),"\n",(0,s.jsx)(a.h2,{id:"schema-and-schemaset",children:"Schema and SchemaSet"}),"\n",(0,s.jsx)(a.p,{children:"The basic specification is the Schema class:"}),"\n",(0,s.jsxs)(a.table,{children:[(0,s.jsx)(a.thead,{children:(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.th,{children:"Field"}),(0,s.jsx)(a.th,{children:"Type"}),(0,s.jsx)(a.th,{children:"Required"}),(0,s.jsx)(a.th,{children:"Description"})]})}),(0,s.jsxs)(a.tbody,{children:[(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"name"}),(0,s.jsx)(a.td,{children:"String"}),(0,s.jsx)(a.td,{children:"Y"}),(0,s.jsx)(a.td,{children:"A unique name for this schema"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"path"}),(0,s.jsx)(a.td,{children:"String"}),(0,s.jsx)(a.td,{children:"Y"}),(0,s.jsx)(a.td,{children:"A full path to a ZNode or a regex pattern to a ZNode"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"documentation"}),(0,s.jsx)(a.td,{children:"String"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"User displayable documentation for this schema"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"schemaValidator"}),(0,s.jsx)(a.td,{children:"SchemaValidator"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"see below"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"ephemeral"}),(0,s.jsx)(a.td,{children:"can/must/cannot"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"Whether the schema allows for ephemerals at the path"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"sequential"}),(0,s.jsx)(a.td,{children:"can/must/cannot"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"Whether the schema allows for sequentials at the path"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"watched"}),(0,s.jsx)(a.td,{children:"can/must/cannot"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"Whether the schema allows for watchers at the path"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"canBeDeleted"}),(0,s.jsx)(a.td,{children:"true/false"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"Whether the schema allows the path to be deleted"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"metadata"}),(0,s.jsx)(a.td,{children:"map"}),(0,s.jsx)(a.td,{children:"N"}),(0,s.jsx)(a.td,{children:"Any fields-to-values you want"})]})]})]}),"\n",(0,s.jsx)(a.p,{children:"All the Schema instances are combined into a SchemaSet and this can be set in the CuratorFrameworkFactory when creating a CuratorFramework instance. Schemas in a SchemaSet are applied in the following order:"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsx)(a.li,{children:"Exact match on full path (i.e. nonregex)"}),"\n",(0,s.jsx)(a.li,{children:"Match on the first regex path, searched in the order given to the SchemaSet constructor"}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"schemavalidator",children:"SchemaValidator"}),"\n",(0,s.jsx)(a.p,{children:"SchemaValidators are used to optionally validate a ZNode operation when the node is created or modified. It is a functor of the form:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:"boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl);\n"})}),"\n",(0,s.jsx)(a.h2,{id:"getting-znode-pathsschemas-by-name",children:"Getting ZNode paths/schemas by name"}),"\n",(0,s.jsx)(a.p,{children:"Use SchemaSets to access ZNode paths by a simple name. E.g.,"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'CuratorFramework client = ...;\nString path = SchemaSet.getNamedPath(client, "locks");\nclient.create().forPath(path);\n'})}),"\n",(0,s.jsx)(a.h2,{id:"loading-json-schema-from-a-filestream",children:"Loading JSON Schema from a file/stream"}),"\n",(0,s.jsx)(a.p,{children:"An optional utility is provided to load SchemaSets from a JSON file or stream: SchemaSetLoader."}),"\n",(0,s.jsx)(a.admonition,{type:"note",children:(0,s.jsx)(a.p,{children:'To avoid adding a new dependency to Curator, the Jackson library has been used with "provided" scope. You will need to add a dependency to jackson-core and jackson-databind to your project.'})}),"\n",(0,s.jsx)(a.p,{children:"The JSON stream should be an array of schemas:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-json",children:'[\n   {\n       "name": "name",                       // required - name of the schema\n       "path": "path or pattern",            // required - full path or regex pattern\n       "isRegex": true/false,                // optional - true if path is a regular expression - default is false\n       "schemaValidator": "name",            // optional - name of a schema validator - default is no validator\n       "documentation": "docs",              // optional - user displayable docs - default is ""\n       "ephemeral": "allowance",             // optional - "can", "must" or "cannot" - default is "can"\n       "sequential": "allowance",            // optional - "can", "must" or "cannot" - default is "can"\n       "watched": "allowance",               // optional - "can", "must" or "cannot" - default is "can"\n       "canBeDeleted": true/false,           // optional - true if ZNode at path can be deleted - default is true\n       "metadata": {                         // optional - any fields -> values that you want\n           "field1": "value1",\n           "field2": "value2"\n       }\n   }\n]\n'})}),"\n",(0,s.jsx)(a.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(a.h3,{id:"example-1",children:"Example 1"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-json",children:'[\n    {\n        "name": "test",\n        "path": "/a/b/c",\n        "ephemeral": "must",\n        "sequential": "cannot",\n        "metadata": {\n            "origin": "outside",\n            "type": "large"\n        }\n    }\n]\n'})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"This SchemaSet has only 1 schema"}),"\n",(0,s.jsx)(a.li,{children:'The schema applies only to the path "/a/b/c"'}),"\n",(0,s.jsx)(a.li,{children:'The ZNode "/a/b/c" must be ephemeral, cannot be sequential, can be watched, and can be deleted'}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"example-2",children:"Example 2"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-json",children:'[\n    {\n        "name": "test",\n        "path": "/a/b/c",\n        "ephemeral": "must",\n        "sequential": "cannot"\n    },\n\n    {\n        "name": "test2",\n        "path": "/a/.*",\n        "isRegex": true,\n        "schemaValidator": "test",\n        "ephemeral": "cannot",\n        "canBeDeleted": false\n    }\n]\n'})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"This SchemaSet has 2 schemas"}),"\n",(0,s.jsx)(a.li,{children:'The first schema applies only to the path "/a/b/c"'}),"\n",(0,s.jsx)(a.li,{children:'The ZNode "/a/b/c" must be ephemeral, cannot be sequential, can be watched, and can be deleted'}),"\n",(0,s.jsx)(a.li,{children:'The second schema is regex and applies to any path that matches the expression "/a/.*"'}),"\n",(0,s.jsx)(a.li,{children:'The ZNodes that match "/a/.*" cannot be ephemeral, can be sequential, can be watched, and cannot be deleted'}),"\n",(0,s.jsx)(a.li,{children:'The second schema also has a schema validator. The schema validator named "test" (configured when constructing the SchemaSetLoader) will be called to validate ZNodes that match "/a/.*".'}),"\n"]})]})}function o(e={}){const{wrapper:a}={...(0,l.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},6413:(e,a,t)=>{t.d(a,{R:()=>i,x:()=>r});var n=t(8101);const s={},l=n.createContext(s);function i(e){const a=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(l.Provider,{value:a},e.children)}}}]);