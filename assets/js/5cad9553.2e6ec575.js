"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[7882],{5975:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>c,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"recipes-distributed-queue","title":"Recipe: Distributed Queue","description":"We recommend that you do NOT use ZooKeeper for Queues. Please see Tech Note 4 for details.","source":"@site/docs/recipes-distributed-queue.md","sourceDirName":".","slug":"/recipes-distributed-queue","permalink":"/docs/recipes-distributed-queue","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/recipes-distributed-queue.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1741292192000,"frontMatter":{"sidebar_label":"Distributed Queue"},"sidebar":"docs","previous":{"title":"Group Member","permalink":"/docs/recipes-group-member"},"next":{"title":"Distributed ID Queue","permalink":"/docs/recipes-distributed-id-queue"}}');var i=s(5105),n=s(6413);const d={sidebar_label:"Distributed Queue"},a="Recipe: Distributed Queue",u={},l=[{value:"Description",id:"description",level:2},{value:"Participating Classes",id:"participating-classes",level:2},{value:"Creating a DistributedQueue",id:"creating-a-distributedqueue",level:3},{value:"General Usage",id:"general-usage",level:2},{value:"Lock Safety",id:"lock-safety",level:2},{value:"Data Format",id:"data-format",level:2},{value:"Error Handling",id:"error-handling",level:2}];function o(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"recipe-distributed-queue",children:"Recipe: Distributed Queue"})}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["We recommend that you do NOT use ZooKeeper for Queues. Please see ",(0,i.jsx)(t.a,{href:"/docs/tech-note-04",children:"Tech Note 4"})," for details."]})}),"\n",(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK's PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer."}),"\n",(0,i.jsx)(t.h2,{id:"participating-classes",children:"Participating Classes"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"QueueBuilder"}),"\n",(0,i.jsx)(t.li,{children:"QueueConsumer"}),"\n",(0,i.jsx)(t.li,{children:"QueueSerializer"}),"\n",(0,i.jsx)(t.li,{children:"DistributedQueue"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"creating-a-distributedqueue",children:"Creating a DistributedQueue"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Parameters:\n// client - the curator client\n// consumer - functor to receive messages\n// serializer - serializer to use for items\n// queuePath - path to store queue\npublic static <T> QueueBuilder<T> builder(\n    CuratorFramework client,\n    QueueConsumer<T> consumer,\n    QueueSerializer<T> serializer,\n    java.lang.String queuePath\n);\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"QueueBuilder<MessageType>    builder = QueueBuilder.builder(client, consumer, serializer, path);\n// ... more builder method calls as needed ...\nDistributedQueue<MessageType queue = builder.build();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"general-usage",children:"General Usage"}),"\n",(0,i.jsxs)(t.p,{children:["The queue must be started via the ",(0,i.jsx)(t.code,{children:"start()"})," method. Call ",(0,i.jsx)(t.code,{children:"close()"})," when you are done with the queue."]}),"\n",(0,i.jsx)(t.p,{children:"To add messages to the queue:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"queue.put(aMessage);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Your consumer (",(0,i.jsx)(t.code,{children:"QueueConsumer.consumeMessage()"}),") will get called as messages arrive."]}),"\n",(0,i.jsx)(t.h2,{id:"lock-safety",children:"Lock Safety"}),"\n",(0,i.jsxs)(t.p,{children:["In the general usage case, the message is removed from the queue prior to the consumer being called. A more atomic mode is provided that removes the item from the queue only after the consumer successfully returns. To enable this mode, call the ",(0,i.jsx)(t.code,{children:"lockPath()"})," method of the Queue Builder. This uses a lock to make the message recoverable. A lock is held while the message is being processed - this prevents other processes from taking the message. The message will not be removed from the queue until the consumer functor returns. Thus, if there is a failure or the process dies, the message will get sent to another process. There is a small performance penalty for this behavior however."]}),"\n",(0,i.jsx)(t.h2,{id:"data-format",children:"Data Format"}),"\n",(0,i.jsx)(t.p,{children:"The Distributed queue writes messages using this format:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Offset"}),(0,i.jsx)(t.th,{children:"Size"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"0"}),(0,i.jsx)(t.td,{children:"4"}),(0,i.jsx)(t.td,{children:"Format version. Currently 0x00010001"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"4"}),(0,i.jsx)(t.td,{children:"1"}),(0,i.jsx)(t.td,{children:"Opcode: 0x01 = message, 0x02 = End of data"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"5"}),(0,i.jsx)(t.td,{children:"4"}),(0,i.jsx)(t.td,{children:"Message byte length"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"9"}),(0,i.jsx)(t.td,{children:"n"}),(0,i.jsx)(t.td,{children:"Message: serialized message bytes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"9 + n"}),(0,i.jsx)(t.td,{children:"..."}),(0,i.jsx)(t.td,{children:"Next set of opcode-size-bytes until end of data"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"QueueConsumer"})," class extends ",(0,i.jsx)(t.code,{children:"ConnectionStateListener"}),". When the queue is started, it adds the listener to the Curator instance. Users of the ",(0,i.jsx)(t.code,{children:"DistributedQueue"})," must pay attention to any connection state changes."]}),"\n",(0,i.jsx)(t.p,{children:"If the SUSPENDED state is reported, the instance must assume that, until it receives a RECONNECTED state, the queue is no longer being updated. If the LOST state is reported, the queue is permanently down."})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},6413:(e,t,s)=>{s.d(t,{R:()=>d,x:()=>a});var r=s(8101);const i={},n=r.createContext(i);function d(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);