"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[9726],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),c=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),h=c(a),u=n,m=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return a?r.createElement(m,l(l({ref:t},d),{},{components:a})):r.createElement(m,l({ref:t},d))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[h]="string"==typeof e?e:n,l[1]=o;for(var c=2;c<i;c++)l[c]=a[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5117:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=a(7462),n=(a(7294),a(3905));const i={sidebar_label:"Leader Latch"},l="Recipe: Leader Latch",o={unversionedId:"recipes-leader-latch",id:"recipes-leader-latch",title:"Recipe: Leader Latch",description:"Description",source:"@site/docs/recipes-leader-latch.md",sourceDirName:".",slug:"/recipes-leader-latch",permalink:"/docs/recipes-leader-latch",draft:!1,editUrl:"https://github.com/apache/curator-site/tree/main/docs/recipes-leader-latch.md",tags:[],version:"current",lastUpdatedBy:"tison",lastUpdatedAt:1692086414,formattedLastUpdatedAt:"Aug 15, 2023",frontMatter:{sidebar_label:"Leader Latch"},sidebar:"docs",previous:{title:"Recipes",permalink:"/docs/recipes"},next:{title:"Leader Election",permalink:"/docs/recipes-leader-election"}},s={},c=[{value:"Description",id:"description",level:2},{value:"Participating Classes",id:"participating-classes",level:2},{value:"Creating a LeaderLatch",id:"creating-a-leaderlatch",level:2},{value:"General Usage",id:"general-usage",level:2},{value:"Error Handling",id:"error-handling",level:2}],d={toc:c},h="wrapper";function p(e){let{components:t,...a}=e;return(0,n.kt)(h,(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"recipe-leader-latch"},"Recipe: Leader Latch"),(0,n.kt)("h2",{id:"description"},"Description"),(0,n.kt)("p",null,'In distributed computing, leader election is the process of designating a single process as the organizer of some task distributed among several computers (nodes). Before the task is begun, all network nodes are unaware which node will serve as the "leader", or coordinator, of the task. After a leader election algorithm has been run, however, each node throughout the network recognizes a particular, unique node as the task leader.'),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"Curator has two leader election recipes. Which one to use depends on your requirements.")),(0,n.kt)("h2",{id:"participating-classes"},"Participating Classes"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"LeaderLatch")),(0,n.kt)("h2",{id:"creating-a-leaderlatch"},"Creating a LeaderLatch"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"// Parameters:\n// client - the client\n// latchPath - the path for this leadership group\npublic LeaderLatch(CuratorFramework client, String latchPath);\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"// Parameters:\n// client - the client\n// latchPath - the path for this leadership group\n// id - participant ID\npublic LeaderLatch(CuratorFramework client, String latchPath, String id);\n")),(0,n.kt)("h2",{id:"general-usage"},"General Usage"),(0,n.kt)("p",null,"LeaderLatches must be started:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"leaderLatch.start();\n")),(0,n.kt)("p",null,"Once started, the LeaderLatch will negotiate with any other LeaderLatch participants that use the same latch path and randomly choose one of them to be the leader. At any time, you can determine if a given instance is the leader by calling:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"// Return true if leadership is currently held by this instance\npublic boolean hasLeadership();\n")),(0,n.kt)("p",null,"Similar to the JDK's CountDownLatch, LeaderLatch has methods that block until leadership is acquired:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"// Causes the current thread to wait until this instance acquires leadership\n// unless the thread is interrupted or closed.\npublic void await() throws InterruptedException, EOFException;\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"// Causes the current thread to wait until this instance acquires leadership unless\n// the thread is interrupted, the specified waiting time elapses or the instance is closed.\n\n// Parameters:\n// timeout - the maximum time to wait\n// unit - the time unit of the timeout argument\n// Returns:\n// true if the count reached zero and false if the waiting time elapsed before the count\n// reached zero or the instances was closed\npublic boolean await(long timeout, TimeUnit unit) throws InterruptedException\n")),(0,n.kt)("p",null,"When you are through with the LeaderLatch instance, you must call close. This removes the instance from the leader election and releases leadership if the instance has it. Once leadership is released, another participating instance (if any) will be chosen as leader."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-java"},"leaderLatch.close();\n")),(0,n.kt)("h2",{id:"error-handling"},"Error Handling"),(0,n.kt)("p",null,"LeaderLatch instances add a ConnectionStateListener to watch for connection problems. If SUSPENDED or LOST is reported, the LeaderLatch that is the leader will report that it is no longer the leader (i.e. there will not be a leader until the connection is re-established). If a LOST connection is RECONNECTED, the LeaderLatch will delete its previous ZNode and create a new one."),(0,n.kt)("p",null,"Users of LeaderLatch must take account that connection issues can cause leadership to be lost. i.e. hasLeadership() returns true but some time later the connection is SUSPENDED or LOST. At that point hasLeadership() will return false. It is highly recommended that LeaderLatch users register a ConnectionStateListener."))}p.isMDXComponent=!0}}]);