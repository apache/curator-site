"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[1797],{3881:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>c});var a=r(8101);const n={},o=a.createContext(n);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},4794:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"tech-note-11","title":"Tech Note 11","description":"Curator internally wraps Watchers.","source":"@site/docs/tech-note-11.md","sourceDirName":".","slug":"/tech-note-11","permalink":"/docs/tech-note-11","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/tech-note-11.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1764930943000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Tech Note 10","permalink":"/docs/tech-note-10"},"next":{"title":"Tech Note 12","permalink":"/docs/tech-note-12"}}');var n=r(5105),o=r(3881);const s={},c="Tech Note 11",i={},h=[{value:"Details",id:"details",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"tech-note-11",children:"Tech Note 11"})}),"\n",(0,n.jsx)(t.p,{children:"Curator internally wraps Watchers."}),"\n",(0,n.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,n.jsx)(t.p,{children:"When you set Watchers using Curator, your Watcher instance is not passed directly to ZooKeeper. Instead, it is wrapped in a special-purpose Curator Watcher (the internal class, NamespaceWatcher). Normally, this is not an issue and is transparent to your client code. However, if you bypass Curator and set a Watcher directly with the ZooKeeper handle, ZooKeeper will not recognize it as the same Watcher set via Curator and that watcher will get called twice when it triggers."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"Watcher myWatcher = ...;\ncurator.getData().usingWatcher(myWatcher).forPath(path);\ncurator.getZookeeperClient().getZooKeeper().getData(path, myWatcher, stat);\n// myWatcher will get called twice when the data for path is changed\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);