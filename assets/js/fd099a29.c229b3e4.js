"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[2209],{4847:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"recipes-distributed-atomic-long","title":"Recipe: Distributed Atomic Long","description":"Description","source":"@site/docs/recipes-distributed-atomic-long.md","sourceDirName":".","slug":"/recipes-distributed-atomic-long","permalink":"/docs/recipes-distributed-atomic-long","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/recipes-distributed-atomic-long.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1737531742000,"frontMatter":{"sidebar_label":"Distributed Atomic Long"},"sidebar":"docs","previous":{"title":"Shared Counter","permalink":"/docs/recipes-shared-counter"},"next":{"title":"Curator Cache","permalink":"/docs/recipes-curator-cache"}}');var r=i(5105),o=i(6755);const c={sidebar_label:"Distributed Atomic Long"},s="Recipe: Distributed Atomic Long",a={},l=[{value:"Description",id:"description",level:2},{value:"Participating Classes",id:"participating-classes",level:2},{value:"Creating a DistributedAtomicLong",id:"creating-a-distributedatomiclong",level:2},{value:"Optimistic mode only",id:"optimistic-mode-only",level:3},{value:"Mutex promotion mode",id:"mutex-promotion-mode",level:3},{value:"General Usage",id:"general-usage",level:2},{value:"Perform an operation on the counter",id:"perform-an-operation-on-the-counter",level:3},{value:"Examine the result AtomicValue",id:"examine-the-result-atomicvalue",level:3},{value:"Error Handling",id:"error-handling",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"recipe-distributed-atomic-long",children:"Recipe: Distributed Atomic Long"})}),"\n",(0,r.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,r.jsx)(t.p,{children:"A counter that attempts atomic increments. It first tries using optimistic locking. If that fails, an optional InterProcessMutex is taken. For both optimistic and mutex, a retry policy is used to retry the increment."}),"\n",(0,r.jsx)(t.h2,{id:"participating-classes",children:"Participating Classes"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"DistributedAtomicLong"}),"\n",(0,r.jsx)(t.li,{children:"AtomicValue"}),"\n",(0,r.jsx)(t.li,{children:"PromotedToLock"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"creating-a-distributedatomiclong",children:"Creating a DistributedAtomicLong"}),"\n",(0,r.jsx)(t.h3,{id:"optimistic-mode-only",children:"Optimistic mode only"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Creates the counter in optimistic mode only - i.e. the promotion to a mutex is not done\n// Parameters:\n// client - the client\n// counterPath - path to hold the counter value\n// retryPolicy - the retry policy to use\npublic DistributedAtomicLong(CuratorFramework client, String counterPath, RetryPolicy retryPolicy);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"mutex-promotion-mode",children:"Mutex promotion mode"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Creates the counter in mutex promotion mode. The optimistic lock will be tried first using the given retry policy.\n// If the increment does not succeed, a InterProcessMutex will be tried with its own retry policy\n//\n// Parameters:\n// client - the client\n// counterPath - path to hold the counter value\n// retryPolicy - the retry policy to use\n// promotedToLock - the arguments for the mutex promotion\npublic DistributedAtomicLong(\n    CuratorFramework client,\n    String counterPath,\n    RetryPolicy retryPolicy,\n    PromotedToLock promotedToLock\n);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"general-usage",children:"General Usage"}),"\n",(0,r.jsx)(t.h3,{id:"perform-an-operation-on-the-counter",children:"Perform an operation on the counter"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"get()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"increment()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"decrement()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"add()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"subtract()"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"examine-the-result-atomicvalue",children:"Examine the result AtomicValue"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["You ",(0,r.jsx)(t.strong,{children:"must"})," first check ",(0,r.jsx)(t.code,{children:"succeeded()"})," which returns true if the operation succeeded. If false is returned, the operation failed and the atomic was not updated."]}),"\n",(0,r.jsxs)(t.li,{children:["If the operation succeeded, you can get the value prior to the operation via ",(0,r.jsx)(t.code,{children:"preValue()"})," and the value after the operation ",(0,r.jsx)(t.code,{children:"postValue()"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(t.p,{children:"All the atomic instances access the ZooKeeper server for each method call. Therefore, the standard retry mechanism will be applied and any errors executing the operations will result in an Exception being thrown."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},6755:(e,t,i)=>{i.d(t,{R:()=>c,x:()=>s});var n=i(8101);const r={},o=n.createContext(r);function c(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);