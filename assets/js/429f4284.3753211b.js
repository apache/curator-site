"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[6378],{6413:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>a});var r=i(8101);const s={},n=r.createContext(s);function o(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(n.Provider,{value:t},e.children)}},9802:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"recipes-distributed-priority-queue","title":"Recipe: Distributed Priority Queue","description":"We recommend that you do NOT use ZooKeeper for Queues. Please see Tech Note 4 for details.","source":"@site/docs/recipes-distributed-priority-queue.md","sourceDirName":".","slug":"/recipes-distributed-priority-queue","permalink":"/docs/recipes-distributed-priority-queue","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/recipes-distributed-priority-queue.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1741292192000,"frontMatter":{"sidebar_label":"Distributed Priority Queue"},"sidebar":"docs","previous":{"title":"Distributed ID Queue","permalink":"/docs/recipes-distributed-id-queue"},"next":{"title":"Distributed Delay Queue","permalink":"/docs/recipes-distributed-delay-queue"}}');var s=i(5105),n=i(6413);const o={sidebar_label:"Distributed Priority Queue"},a="Recipe: Distributed Priority Queue",u={},d=[{value:"Description",id:"description",level:2},{value:"Participating Classes",id:"participating-classes",level:2},{value:"Creating a DistributedPriorityQueue",id:"creating-a-distributedpriorityqueue",level:2},{value:"General Usage",id:"general-usage",level:2},{value:"Lock Safety",id:"lock-safety",level:2},{value:"Data Format",id:"data-format",level:2},{value:"Error Handling",id:"error-handling",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"recipe-distributed-priority-queue",children:"Recipe: Distributed Priority Queue"})}),"\n",(0,s.jsx)(t.admonition,{type:"caution",children:(0,s.jsxs)(t.p,{children:["We recommend that you do NOT use ZooKeeper for Queues. Please see ",(0,s.jsx)(t.a,{href:"/docs/tech-note-04",children:"Tech Note 4"})," for details."]})}),"\n",(0,s.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(t.p,{children:"An implementation of the Distributed Priority Queue ZK recipe."}),"\n",(0,s.jsx)(t.h2,{id:"participating-classes",children:"Participating Classes"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"QueueBuilder"}),"\n",(0,s.jsx)(t.li,{children:"QueueConsumer"}),"\n",(0,s.jsx)(t.li,{children:"QueueSerializer"}),"\n",(0,s.jsx)(t.li,{children:"DistributedPriorityQueue"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"creating-a-distributedpriorityqueue",children:"Creating a DistributedPriorityQueue"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// Parameters:\n// client - the curator client\n// consumer - message consumer\n// serializer - serializer to use for items\n// queuePath - path to store queue\npublic static <T> QueueBuilder<T> builder(\n    CuratorFramework client,\n    QueueConsumer<T> consumer,\n    QueueSerializer<T> serializer,\n    java.lang.String queuePath\n);\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"QueueBuilder<MessageType> builder = QueueBuilder.builder(client, consumer, serializer, path);\n// ... more builder method calls as needed ...\nDistributedPriorityQueue<MessageType> queue = builder.buildPriorityQueue(minItemsBeforeRefresh);\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// Parameters:\n// minItemsBeforeRefresh - minimum items to process before refreshing the item list\npublic DistributedPriorityQueue<T> buildPriorityQueue(int minItemsBeforeRefresh);\n"})}),"\n",(0,s.jsx)(t.p,{children:"Build a DistributedPriorityQueue from the current builder values."}),"\n",(0,s.jsx)(t.p,{children:"When the priority queue detects an item addition/removal, it will stop processing its current list of items and refresh the list. minItemsBeforeRefresh modifies this. It determines the minimum number of items from the active list that will get processed before a refresh."}),"\n",(0,s.jsx)(t.p,{children:"Due to a quirk in the way ZooKeeper notifies changes, the queue will get an item addition/remove notification after every item is processed. This can lead to poor performance. Set minItemsBeforeRefresh to the value your application can tolerate being out of sync."}),"\n",(0,s.jsx)(t.p,{children:"For example: if the queue sees 10 items to process, it will end up making 10 calls to ZooKeeper to check status. You can control this by setting minItemsBeforeRefresh to 10 (or more) and the queue will only refresh with ZooKeeper after 10 items are processed"}),"\n",(0,s.jsx)(t.h2,{id:"general-usage",children:"General Usage"}),"\n",(0,s.jsxs)(t.p,{children:["The queue must be started via the ",(0,s.jsx)(t.code,{children:"start()"})," method. Call ",(0,s.jsx)(t.code,{children:"close()"})," when you are done with the queue."]}),"\n",(0,s.jsx)(t.p,{children:"To add messages to the queue:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"queue.put(aMessage, priority);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The consumer (",(0,s.jsx)(t.code,{children:"QueueConsumer.consumeMessage()"}),") will get called as messages arrive."]}),"\n",(0,s.jsx)(t.h2,{id:"lock-safety",children:"Lock Safety"}),"\n",(0,s.jsxs)(t.p,{children:["In the general usage case, the message is removed from the queue prior to the consumer being called. A more atomic mode is provided that removes the item from the queue only after the consumer successfully returns. To enable this mode, call the ",(0,s.jsx)(t.code,{children:"lockPath()"})," method of the Queue Builder. This uses a lock to make the message recoverable. A lock is held while the message is being processed - this prevents other processes from taking the message. The message will not be removed from the queue until the consumer functor returns. Thus, if there is a failure or the process dies, the message will get sent to another process. There is a small performance penalty for this behavior, however."]}),"\n",(0,s.jsx)(t.h2,{id:"data-format",children:"Data Format"}),"\n",(0,s.jsxs)(t.p,{children:["Same as ",(0,s.jsx)(t.a,{href:"/docs/recipes-distributed-queue#data-format",children:"Distributed Queue"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"QueueConsumer"})," class extends ",(0,s.jsx)(t.code,{children:"ConnectionStateListener"}),". When the queue is started, it adds the listener to the Curator instance. Users of the ",(0,s.jsx)(t.code,{children:"DistributedPriorityQueue"})," must pay attention to any connection state changes."]}),"\n",(0,s.jsx)(t.p,{children:"If the SUSPENDED state is reported, the instance must assume that, until it receives a RECONNECTED state, the queue is no longer being updated. If the LOST state is reported, the queue is permanently down."})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);