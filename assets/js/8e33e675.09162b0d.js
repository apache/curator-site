"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[6677],{4170:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"recipes","title":"Recipes","description":"Curator implements all the recipes listed on the ZooKeeper recipes doc (except two phase commit). Click on the recipe name below for detailed documentation.","source":"@site/docs/recipes.md","sourceDirName":".","slug":"/recipes","permalink":"/docs/recipes","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/recipes.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1741292192000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Examples","permalink":"/docs/examples"},"next":{"title":"Leader Latch","permalink":"/docs/recipes-leader-latch"}}');var i=r(5105),a=r(6413);const n={},o="Recipes",c={},d=[{value:"Elections",id:"elections",level:2},{value:"Locks",id:"locks",level:2},{value:"Barriers",id:"barriers",level:2},{value:"Counters",id:"counters",level:2},{value:"Caches",id:"caches",level:2},{value:"Nodes/Watches",id:"nodeswatches",level:2},{value:"Queues",id:"queues",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"recipes",children:"Recipes"})}),"\n",(0,i.jsx)(t.p,{children:"Curator implements all the recipes listed on the ZooKeeper recipes doc (except two phase commit). Click on the recipe name below for detailed documentation."}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["Curator recipes will automatically create parent nodes of paths given to the recipe as ",(0,i.jsx)(t.code,{children:"CreateMode.CONTAINER"}),". Also, see ",(0,i.jsx)(t.a,{href:"/docs/tech-note-07",children:"Tech Note 7"}),' regarding "Curator Recipes Own Their ZNode/Paths".']})}),"\n",(0,i.jsx)(t.h2,{id:"elections",children:"Elections"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-leader-latch",children:"Leader Latch"}),' - In distributed computing, leader election is the process of designating a single process as the organizer of some task distributed among several computers (nodes). Before the task is begun, all network nodes are unaware which node will serve as the "leader," or coordinator, of the task. After a leader election algorithm has been run, however, each node throughout the network recognizes a particular, unique node as the task leader.']}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-leader-election",children:"Leader Election"})," - Initial Curator leader election recipe."]}),"\n",(0,i.jsx)(t.h2,{id:"locks",children:"Locks"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-shared-reentrant-lock",children:"Shared Reentrant Lock"})," - Fully distributed locks that are globally synchronous, meaning at any snapshot in time no two clients think they hold the same lock."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-shared-lock",children:"Shared Lock"})," - Similar to Shared Reentrant Lock but not reentrant."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-shared-reentrant-read-write-lock",children:"Shared Reentrant Read Write Lock"})," - A re-entrant read/write mutex that works across JVMs. A read write lock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader processes, so long as there are no writers. The write lock is exclusive."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-shared-semaphore",children:"Shared Semaphore"}),' - A counting semaphore that works across JVMs. All processes in all JVMs that use the same lock path will achieve an inter-process limited set of leases. Further, this semaphore is mostly "fair" - each user will get a lease in the order requested (from ZK\'s point of view).']}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-multi-shared-lock",children:"Multi Shared Lock"})," - A container that manages multiple locks as a single entity. When acquire() is called, all the locks are acquired. If that fails, any paths that were acquired are released. Similarly, when release() is called, all locks are released (failures are ignored)."]}),"\n",(0,i.jsx)(t.h2,{id:"barriers",children:"Barriers"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-barrier",children:"Barrier"})," - Distributed systems use barriers to block processing of a set of nodes until a condition is met at which time all the nodes are allowed to proceed."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-double-barrier",children:"Double Barrier"})," - Double barriers enable clients to synchronize the beginning and the end of a computation. When enough processes have joined the barrier, processes start their computation and leave the barrier once they have finished."]}),"\n",(0,i.jsx)(t.h2,{id:"counters",children:"Counters"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-shared-counter",children:"Shared Counter"})," - Manages a shared integer. All clients watching the same path will have the up-to-date value of the shared integer (considering ZK's normal consistency guarantees)."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-distributed-atomic-long",children:"Distributed Atomic Long"})," - A counter that attempts atomic increments. It first tries using optimistic locking. If that fails, an optional InterProcessMutex is taken. For both optimistic and mutex, a retry policy is used to retry the increment."]}),"\n",(0,i.jsx)(t.h2,{id:"caches",children:"Caches"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-curator-cache",children:"Curator Cache"})," - A utility that attempts to keep the data from a node locally cached. Optionally the entire tree of children below the node can also be cached. Will respond to update/create/delete events, pull down the data, etc. You can register listeners that will get notified when changes occur."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-path-cache",children:"Path Cache"})," - (For preZooKeeper 3.6.x) A Path Cache is used to watch a ZNode. Whenever a child is added, updated or removed, the Path Cache will change its state to contain the current set of children, the children's data and the children's state. Path caches in the Curator Framework are provided by the PathChildrenCache class. Changes to the path are passed to registered PathChildrenCacheListener instances."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-node-cache",children:"Node Cache"})," - (For preZooKeeper 3.6.x) A utility that attempts to keep the data from a node locally cached. This class will watch the node, respond to update/create/delete events, pull down the data, etc. You can register a listener that will get notified when changes occur."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-tree-cache",children:"Tree Cache"})," - (For preZooKeeper 3.6.x) A utility that attempts to keep all data from all children of a ZK path locally cached. This class will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can register a listener that will get notified when changes occur."]}),"\n",(0,i.jsx)(t.h2,{id:"nodeswatches",children:"Nodes/Watches"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-persistent-watcher",children:"Persistent Recursive Watcher"})," - A managed persistent recursive watcher. The watch will be managed such that it stays set through connection lapses, etc."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-persistent-node",children:"Persistent Node"})," - A node that attempts to stay present in ZooKeeper, even through connection and session interruptions."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-persistent-ttl-node",children:"Persistent TTL Node"})," - Useful when you need to create a TTL node but don't want to keep it alive manually by periodically setting data."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-group-member",children:"Group Member"})," - Group membership management. Adds this instance into a group and keeps a cache of"]}),"\n",(0,i.jsx)(t.h2,{id:"queues",children:"Queues"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-distributed-queue",children:"Distributed Queue"})," - An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK's PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-distributed-id-queue",children:"Distributed ID Queue"})," - A version of DistributedQueue that allows IDs to be associated with queue items. Items can then be removed from the queue if needed."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-distributed-priority-queue",children:"Distributed Priority Queue"})," - An implementation of the Distributed Priority Queue ZK recipe."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-distributed-delay-queue",children:"Distributed Delay Queue"})," - An implementation of a Distributed Delay Queue."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/recipes-simple-distributed-queue",children:"Simple Distributed Queue"})," - A drop-in replacement for the DistributedQueue that comes with the ZK distribution."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},6413:(e,t,r)=>{r.d(t,{R:()=>n,x:()=>o});var s=r(8101);const i={},a=s.createContext(i);function n(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:n(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);