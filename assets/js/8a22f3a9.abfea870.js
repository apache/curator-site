"use strict";(self.webpackChunkcurator_site=self.webpackChunkcurator_site||[]).push([[9257],{5842:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"errors","title":"Error Handling","description":"Background","source":"@site/docs/errors.md","sourceDirName":".","slug":"/errors","permalink":"/docs/errors","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/curator-site/tree/main/docs/errors.md","tags":[],"version":"current","lastUpdatedBy":"tison","lastUpdatedAt":1741292192000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Client","permalink":"/docs/client"},"next":{"title":"Logging and Tracing","permalink":"/docs/logging"}}');var o=n(5105),s=n(6413);const i={},a="Error Handling",c={},l=[{value:"Background",id:"background",level:2},{value:"Connection Guarantees",id:"connection-guarantees",level:2},{value:"Notifications",id:"notifications",level:2},{value:"Error Policy",id:"error-policy",level:2},{value:"Recipes",id:"recipes",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,o.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,o.jsx)(t.p,{children:"ZooKeeper is a very low level system that requires users to do a lot of housekeeping. See:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ",children:"https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ"})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The Curator ",(0,o.jsx)(t.a,{href:"/docs/framework",children:"Framework"})," is designed to hide as much of the details/tedium of this housekeeping as is possible."]}),"\n",(0,o.jsx)(t.h2,{id:"connection-guarantees",children:"Connection Guarantees"}),"\n",(0,o.jsx)(t.p,{children:"The Curator Framework constantly monitors the connection to the ZooKeeper ensemble. Further every operation is wrapped in a retry mechanism. Thus, the following guarantees can be made:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Every Curator operation properly waits until the ZooKeeper connection is established"}),"\n",(0,o.jsx)(t.li,{children:"Every Curator Framework operation (create, getData, etc.) is guaranteed to manage connection loss and/or session expiration per the currently set retry policy"}),"\n",(0,o.jsx)(t.li,{children:"If the connection is temporarily lost, Curator will attempt to retry the operation until it succeeds per the currently set retry policy"}),"\n",(0,o.jsx)(t.li,{children:"All Curator recipes attempt to deal with connection issues in an appropriate way"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"notifications",children:"Notifications"}),"\n",(0,o.jsx)(t.p,{children:"Curator exposes several listenable interfaces for clients to monitor the state of the ZooKeeper connection."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"ConnectionStateListener"})," is called when there are connection disruptions. Clients can monitor these changes and take appropriate action. These are the possible state changes:"]}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{children:"State Change"}),(0,o.jsx)(t.th,{children:"Description"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"CONNECTED"}),(0,o.jsx)(t.td,{children:"Sent for the first successful connection to the server. NOTE: You will only get one of these messages for any CuratorFramework instance."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"READONLY"}),(0,o.jsxs)(t.td,{children:["The connection has gone into read-only mode. This can only happen if you pass true for CuratorFrameworkFactory.Builder.canBeReadOnly(). See the ZooKeeper doc regarding read only connections: ",(0,o.jsx)(t.a,{href:"https://cwiki.apache.org/confluence/display/HADOOP2/ZooKeeper+GSoCReadOnlyMode",children:"https://cwiki.apache.org/confluence/display/HADOOP2/ZooKeeper+GSoCReadOnlyMode"}),". The connection will remain in read only mode until another state change is sent."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SUSPENDED"}),(0,o.jsx)(t.td,{children:"There has been a loss of connection. Leaders, locks, etc. should suspend until the connection is re-established."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"RECONNECTED"}),(0,o.jsx)(t.td,{children:"A suspended or lost connection has been re-established."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"LOST"}),(0,o.jsx)(t.td,{children:"Curator will set the LOST state when it believes that the ZooKeeper session has expired. ZooKeeper connections have a session. When the session expires, clients must take appropriate action. In Curator, this is complicated by the fact that Curator internally manages the ZooKeeper connection. Curator will set the LOST state when any of the following occurs: a) ZooKeeper returns a Watcher.Event.KeeperState.Expired or KeeperException.Code.SESSIONEXPIRED; b) Curator closes the internally managed ZooKeeper instance; c) The session timeout elapses during a network partition. It is possible to get a RECONNECTED state after this but you should still consider any locks, etc. as dirty/unstable. NOTE: The meaning of LOST has changed since Curator 3.0.0. Prior to 3.0.0 LOST only meant that the retry policy had expired."})]})]})]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"UnhandledErrorListener"})," is called when a background task, etc. catches an exception. In general, Curator users shouldn't care about these as they are logged. However, you can listen for them if you choose."]}),"\n",(0,o.jsx)(t.h2,{id:"error-policy",children:"Error Policy"}),"\n",(0,o.jsxs)(t.p,{children:["Curator has a pluggable error policy. The default policy takes the conservative approach of treating connection states SUSPENDED and LOST the same way. i.e. when a recipe sees the state change to SUSPENDED it will assume that the ZooKeeper session is lost and will clean up any watchers, nodes, etc. You can choose, however, a more aggressive approach by setting the error policy to only treat LOST (i.e. true session loss) as an error state. Do this in the CuratorFrameworkFactory via: ",(0,o.jsx)(t.code,{children:"connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy())"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"recipes",children:"Recipes"}),"\n",(0,o.jsx)(t.p,{children:"In general, the recipes attempt to deal with errors and connection issues. See the doc for each recipe for details on how it deals with errors."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},6413:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(8101);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);